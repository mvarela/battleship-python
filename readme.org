#+TITLE: Battleship (in Python)
#+LANGUAGE: en
#+OPTIONS: toc:t h:4 html-postamble:nil html-preamble:t tex:t f:t
#+OPTIONS: tags:nil
# #+OPTIONS: prop:("VERSION")
#+OPTIONS: broken-links:t
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="css/style.css" rel="stylesheet" type="text/css" />
#+AUTHOR: Martín Varela
#+EMAIL: martin@varela.fi

#+setupfile: ./styles/rto.setup
#+LINK: gh    https://github.com/
#+LINK: rfc   https://tools.ietf.org/html/
#+LINK: thing https://github.com/thi-ng/
#+LINK: w3    https://w3.org/TR/
#+LINK: wiki  https://en.wikipedia.org/wiki/
#+PROPERTY: header-args :eval never-export
#+TOC: headlines 1 

#+TODO: TODO(t) OPTIONAL(o) | DONE(d) CANCELED(c)
#+TODO: TESTING(e) BUG(b) | FIXED(f)

#+begin_src emacs-lisp :exports none
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (jupyter . t)))
    (setq-local org-tangle-root-dir "./battleship")
    (setq-local org-tangle-on-save t)
#+end_src

#+RESULTS:
: t


* Battleship

** Requirements
   
   The requirements defined are as follows:
   
   - Implement a game of "Battleship" in Python
   - The play mode is a human player vs an "AI", which should be smarter than simply firing at random positions
   - The board should be a 10x10 grid
     - Note: this will be the default, but the API shall be more generic
   - Each player has 5 ships, of lengths 2, 3, 4 and 5 (with two instances of the ship of length 3)
     - Note: again, the API will allow for more generality, but the default will be this
   - Ships can be positioned either vertically or horizontally, and may not overlap
   - The game proceeds as a sequence of alternating rounds (first player is chosen randomly)
     - In each round, each player choses a (free) square in the grid to fire at, and is notified of whether the shot hit water, or an enemy's ship.
     - Once a ship has been hit in all its length, it is sunk.
   - The game ends when a player sinks all the oponent's ships.
     
     
** Data Model & Implementation
   - The core of the problem lies in representing the board's state, and its transitions.
     - The grid itself can be represented as an array of arrays (I guess list of
       lists in Python's parlance), and within each cell in the grid, we
       represent the known state, which can be one of the following:
       - Empty / water (there is no ship here). An empty cell can be revealed as water to the opponent once it's hit.
       - Ship. This cell corresponds to a ship. The ships themselves do not
         carry much state, but we can represent them as a =length=, and a set of
         hits, representing the cells which have been hit, if any. On the board
         itself, each ship cell could point to an actual =Ship= object
         containing this data.
         - For display purposes, and for the AI, we need to distinguish between
           damaged and non-damaged cells in the ship. This can be inferred from
           the set of hits in the ship's representation
     - A set of ships, for easy access to the ships' data (e.g, for determining whether all ships have been sunk)
     - The game itself consists of two boards, one for each player, and the
       current state of the AI (that is, the AI will need to remember what it
       was "currently doing / planning on doing" at the last turn.
         
*** Setup
    
#+begin_src jupyter-python :exports code :results silent :eval never :tangle "setup.py"
from setuptools import setup

setup(name='battleship',
      version = '0.1',
      description = 'Battleship clone',
      author = 'Martín Varela',
      author_email = 'martin@varela.fi',
      packages = ['battleship'],
      zip_safe = False)
#+end_src

We initialize the module
#+begin_src jupyter-python :exports code :results silent :eval never :tangle "battleship/__init__.py"
from battleship.board  import *
from battleship.pieces import *
from battleship.ship   import *
from battleship.ai     import *
#+end_src
*** Board and Ships
     
    Our board's main feature will be a grid in which we represent the state of
the game. We can have cells that are either empty, or part of a ship. In
addition, if the cell has been hit, we can distinguish between water, and a part
of a ship that's been hit. A simple dictionary would be sufficient to represent
this information, but in a more OO-friendly way we can implement a simple class
hierarchy for representing this data, which we can then exploit for rendering
the board by having each piece =draw= itself. Likewise, we can have each piece
respond to whether it is empty.

#+begin_src jupyter-python :exports code :results silent :eval never :tangle "battleship/pieces.py"
  class Piece():
      def draw(this, opponentView = False):
          return " "

      def isEmpty(this):
        return True

  class EmptyPiece(Piece):
      pass

  class WaterPiece(Piece):
      def draw(this, opponentView = False):
          return "W"

  class ShipPiece(Piece):
      def __init__(this, shipId, index):
          """

          """
          this.shipId = shipId
          this.index = index
      def draw(this, opponentView = False):
          if opponentView:
              return " "
          else:
              return "S"

      def isEmpty(this):
        return False


  class HitShipPiece(ShipPiece):
      def draw(this, opponentView = False):
          return "H"

      def isEmpty(this):
        return False
#+end_src

Coming to our board, we can now create the basic functionality. We need to:
- Create a new board, initializing the cells to =EmptyPiece= instances.
- Check whether we can add a ship, given its orientation and a starting pair of =(x,y)= coordinates
- Add a ship, given a pair of =(x,y)= coordinates, ship length, and an orientation (provided it can be added)
- Fire at a location
- Check whether the board is "lost" (that is, all ships have been sunk)

#+begin_src jupyter-python :exports code :results silent :eval never :tangle "battleship/board.py" :noweb yes
  from battleship.pieces import (EmptyPiece, WaterPiece,
               ShipPiece, HitShipPiece)
  from enum import Enum
  from random import choice, randint
  <<shipImport>>


  class Orientation(Enum):
     horizontal = 0
     vertical = 1

  <<boardHitEnum>>

  class Board:
    """Represents the core of our data model: a rectangular grid where we can
  position ships, fire upon them, and check the status of a grid cell that has
  been fired upon.

    """
    def __init__(self, width, height):
      self.height = height
      self.width = width
      self.grid = [[EmptyPiece() for y in range(height)] for x in range(width)]
      self.ships = {}

    def rowString(self, n, opponentView = False):
      if n <= self.height:
        rowStr = ' | '.join([self.grid[i][n].draw(opponentView) for i in range(self.width)])
        return('| ' + rowStr + ' |\n')
      else:
        return ''

    def printBoard(self, opponentView = False):
      rows = [self.rowString(i, opponentView) for i in range(self.height)]
      header = '  ' + '| '  + ' | '.join(['%s' %i for i in range(0,self.width)]) + ' |'
      hsep =  ''.join(['_' for i in range(0, len(header))]) + '\n'
      print(header)
      print(hsep)
      for idx, r in enumerate(rows):
        # we ommit the index string padding for simplicity, since it'll be <10 in the game
        print(str(idx) + ' ' +r)

    <<canAdd>>

    <<addShip>>

    <<boardFire>>

    <<boardPopulate>>
  
    <<boardLost>>

#+end_src

The first thing to do is add functionality for adding a ship. This requires both
checking whether a ship of a given size can be placed at a certain =(x,y)=
position with the given orientation, and actually adding the ship in place.
We'll keep the ships' state in a =dict= object in the board, and the
corresponding =piece= objects on the grid can reference the ship's =id= for
accessing ship state as necessary.

#+begin_src python :exports code :results silent :eval never :noweb-ref canAdd
  def positions(self, x, y, length, orientation):
     """Auxiliary function to return the coordinates occupied by adding a ship"""
     if x < 0 or y < 0:
        return False
     xEnd = x
     yEnd = y
     if(orientation == Orientation.horizontal):
        xEnd = x + length
     else:
        yEnd = y + length

     if xEnd >= self.width or yEnd >= self.height:
         return False
     else:
        if orientation == Orientation.horizontal:
           return [(i,y) for i in range(x, xEnd)]
        else:
           return [(x,j) for j in range(y, yEnd)]

  def canAdd(self, x, y, length, orientation):
     positions = self.positions(x, y, length, orientation)
     if positions:
        cells = [self.grid[x][y].isEmpty() for (x,y) in positions]
        return all(cells)
     else:
        return False
#+end_src

We can now add ships, but of course for that we need to represent them, first:

#+begin_src python :exports code :results silent :eval never :tangle "battleship/ship.py" :noweb yes
  class Ship:
      def __init__(self, length):
          self.length = length
          self.hits = set()

      def hit(self, index):
          """ Register a hit at position `index`"""
          if index <= self.length:
              self.hits.add(index)

      def isSunk(self):
          """True if the ship is sunk"""
          return len(self.hits) == self.length
#+end_src

With our =Ship= definition at hand, we can now do:


#+begin_src python :exports code :results silent :eval never :noweb-ref shipImport
  from battleship.ship import Ship
  from uuid import uuid4
#+end_src



#+begin_src python :exports code :results silent :eval never :noweb-ref addShip
  def addShip(self, x, y, length, orientation):
      if self.canAdd(x, y, length, orientation):
          ship = Ship(length)
          coords = self.positions(x, y, length, orientation)
          id = uuid4()
          self.ships[id] = ship
          for idx, (i, j) in enumerate(coords):
              self.grid[i][j] = ShipPiece(id, idx)
          return True
      else:
          return False
#+end_src


Now it would be a good time to do some basic testing for the functionality we
have. We will use property-based testing, using =Hypothesis=. 

We add it to our dependencies:
#+begin_src sh :exports code :results silent :eval never :noweb yes :tangle "requirements.txt"
  Hypothesis==5.6.0
  Pytest==5.3.5
  Pytest-cov==2.8.1
#+end_src

And install it:
#+begin_src sh :exports both :results output 
pip3 install -r requirements.txt
#+end_src

#+RESULTS:
#+begin_example
Collecting Hypothesis==5.6.0 (from -r requirements.txt (line 1))
  Using cached https://files.pythonhosted.org/packages/51/19/0c2931f0ab4da3ac0720a36538515597090178731f74b2c8832a2032687a/hypothesis-5.6.0-py3-none-any.whl
Collecting Pytest==5.3.5 (from -r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/a5/c0/34033b2df7718b91c667bd259d5ce632ec3720198b7068c0ba6f6104ff89/pytest-5.3.5-py3-none-any.whl
Collecting Pytest-cov==2.8.1 (from -r requirements.txt (line 3))
  Downloading https://files.pythonhosted.org/packages/b9/54/3673ee8be482f81527678ac894276223b9814bb7262e4f730469bb7bf70e/pytest_cov-2.8.1-py2.py3-none-any.whl
Collecting sortedcontainers<3.0.0,>=2.1.0 (from Hypothesis==5.6.0->-r requirements.txt (line 1))
  Using cached https://files.pythonhosted.org/packages/13/f3/cf85f7c3a2dbd1a515d51e1f1676d971abe41bba6f4ab5443240d9a78e5b/sortedcontainers-2.1.0-py2.py3-none-any.whl
Collecting attrs>=19.2.0 (from Hypothesis==5.6.0->-r requirements.txt (line 1))
  Using cached https://files.pythonhosted.org/packages/a2/db/4313ab3be961f7a763066401fb77f7748373b6094076ae2bda2806988af6/attrs-19.3.0-py2.py3-none-any.whl
Collecting py>=1.5.0 (from Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/99/8d/21e1767c009211a62a8e3067280bfce76e89c9f876180308515942304d2d/py-1.8.1-py2.py3-none-any.whl
Collecting more-itertools>=4.0.0 (from Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/72/96/4297306cc270eef1e3461da034a3bebe7c84eff052326b130824e98fc3fb/more_itertools-8.2.0-py3-none-any.whl
Collecting packaging (from Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/98/42/87c585dd3b113c775e65fd6b8d9d0a43abe1819c471d7af702d4e01e9b20/packaging-20.1-py2.py3-none-any.whl
Collecting importlib-metadata>=0.12; python_version < "3.8" (from Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/8b/03/a00d504808808912751e64ccf414be53c29cad620e3de2421135fcae3025/importlib_metadata-1.5.0-py2.py3-none-any.whl
Collecting pluggy<1.0,>=0.12 (from Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/a0/28/85c7aa31b80d150b772fbe4a229487bc6644da9ccb7e427dd8cc60cb8a62/pluggy-0.13.1-py2.py3-none-any.whl
Collecting wcwidth (from Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/58/b4/4850a0ccc6f567cc0ebe7060d20ffd4258b8210efadc259da62dc6ed9c65/wcwidth-0.1.8-py2.py3-none-any.whl
Collecting coverage>=4.4 (from Pytest-cov==2.8.1->-r requirements.txt (line 3))
  Downloading https://files.pythonhosted.org/packages/6a/58/df86640436e28ca46fa5e93e603c82abb0cba309b37cbaec1e1188ea53a6/coverage-5.0.3-cp36-cp36m-manylinux1_x86_64.whl (227kB)
Collecting six (from packaging->Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/65/eb/1f97cb97bfc2390a276969c6fae16075da282f5058082d4cb10c6c5c1dba/six-1.14.0-py2.py3-none-any.whl
Collecting pyparsing>=2.0.2 (from packaging->Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/5d/bc/1e58593167fade7b544bfe9502a26dc860940a79ab306e651e7f13be68c2/pyparsing-2.4.6-py2.py3-none-any.whl
Collecting zipp>=0.5 (from importlib-metadata>=0.12; python_version < "3.8"->Pytest==5.3.5->-r requirements.txt (line 2))
  Using cached https://files.pythonhosted.org/packages/b2/34/bfcb43cc0ba81f527bc4f40ef41ba2ff4080e047acb0586b56b3d017ace4/zipp-3.1.0-py3-none-any.whl
Installing collected packages: sortedcontainers, attrs, Hypothesis, py, more-itertools, six, pyparsing, packaging, zipp, importlib-metadata, pluggy, wcwidth, Pytest, coverage, Pytest-cov
Successfully installed Hypothesis-5.6.0 Pytest-5.3.5 Pytest-cov-2.8.1 attrs-19.3.0 coverage-5.0.3 importlib-metadata-1.5.0 more-itertools-8.2.0 packaging-20.1 pluggy-0.13.1 py-1.8.1 pyparsing-2.4.6 six-1.14.0 sortedcontainers-2.1.0 wcwidth-0.1.8 zipp-3.1.0
#+end_example


#+begin_src python :exports code :results silent :eval never :tangle "battleship/test_board.py" :noweb yes
  from battleship.board import Board, Orientation
  from battleship.ship import Ship
  from battleship.pieces import EmptyPiece, WaterPiece, ShipPiece, HitShipPiece
  from hypothesis import given, strategies as st


  @given(st.integers(min_value=0, max_value=9),
         st.integers(min_value=0, max_value=9),
         st.integers(min_value=2, max_value=5),
         st.sampled_from(Orientation))
  def testShipAdd(x, y, length, orientation):
      """We test that we can add valid combinations of coordinates, lengths and orientations to a board"""
      b = Board(10,10)
      if orientation == Orientation.vertical:
          if(y + length < b.height):
              assert(True == b.addShip(x, y, length, orientation))
          else:
            assert(False == b.addShip(x, y, length, orientation))
      else:
          if(x + length < b.width):
              assert(True == b.addShip(x, y, length, orientation))
          else:
            assert(False == b.addShip(x, y, length, orientation))


  def auxCoordsSameAxis(x, y, length, orientation):
      """Auxiliary function for the test below"""
      if orientation == Orientation.horizontal:
          xrange =  [i for i in
                     range(x - (length // 2), x + (length // 2))
                     if i >= 0]
          yrange = [y]
      else:
          xrange = [x]
          yrange = [i for i in
                    range(y - (length // 2), y + (length //2))
                    if i >= 0]
      return [(i, j) for i in xrange for j in yrange]

  def auxCoordsOppositeAxis(x, y, length):
      """Auxiliary function for the test below"""
      xrange =  [i for i in
                 range(x - (length // 2), x + (length // 2))
                 if i >= 0]
      yrange = [i for i in
                range(y - (length // 2), y + (length //2))
                if i >= 0]
      return [(i, j) for i in xrange for j in yrange]

  @given(st.data())
  def testNonOverlappingShips(data):
      """We test that given a randomly placed (random) ship, another similar ship
  cannot be placed in an overlapping position. We check for overlapping positions in
      the both orientations"""

      opposites = {Orientation.horizontal : Orientation.vertical,
                   Orientation.vertical : Orientation.horizontal}
      side = 10
      lengthGen = st.integers(min_value=2, max_value=5)
      length = data.draw(lengthGen)
      orientation = data.draw(st.sampled_from(Orientation))
      startingCoord = st.integers(min_value = 0, max_value = (side - length))
      x = data.draw(startingCoord)
      y = data.draw(startingCoord)
      b = Board(side, side)
      if(b.canAdd(x, y, length, orientation)):
          b.addShip(x, y, length, orientation)
          sameOrientationCoords = auxCoordsSameAxis(x, y, length, orientation)
          sameOrientationChecks = [b.canAdd(i, j, length, orientation)
                                   for (i, j) in sameOrientationCoords]
          assert(not(any(sameOrientationChecks)))
          newOrientation = opposites[orientation]
          newOrientationCoords = auxCoordsOppositeAxis(x, y, length)
          newOrientationChecks = [b.canAdd(i, j, length, newOrientation)
                                  for (i, j) in newOrientationCoords]
          print(not(any(newOrientationChecks)))



  <<fireTests>>
#+end_src



We can check how our code is behaving so far:
#+begin_src sh :exports both :results output 
pytest --cov=./
#+end_src

#+RESULTS:
#+begin_example
============================= test session starts ==============================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/mvr/Devel/Python/battleship
plugins: cov-2.8.1, hypothesis-5.6.0
collected 1 item

battleship/test_board.py .                                               [100%]

----------- coverage: platform linux, python 3.6.9-final-0 -----------
Name                       Stmts   Miss  Cover
----------------------------------------------
battleship/board.py           49      7    86%
battleship/pieces.py          24      7    71%
battleship/ship.py             9      3    67%
battleship/test_board.py      13      0   100%
setup.py                       2      2     0%
----------------------------------------------
TOTAL                         97     19    80%


============================== 1 passed in 0.23s ===============================
#+end_example

With this basic testing in place, we can go back to our =Board= class, and add
the functionality for firing. When firing at a position, we should get an
indication of what was hit, and whether a ship was sunk. We can do this with
just an enum for now.


#+begin_src python :exports code :results silent :eval never :noweb-ref boardHitEnum
  class FireResult(Enum):
      water = 0
      hit = 1
      sunk = 2
#+end_src

We now define the =fire= method

#+begin_src python :exports code :results silent :eval never :noweb-ref boardFire
  def fire(self,x,y):
      result = FireResult.water
      if x < self.width and y < self.height:
          piece = self.grid[x][y]
          if piece.isEmpty():
              self.grid[x][y] = WaterPiece()
          else:
              idx = piece.index
              shipId = piece.shipId
              self.ships[shipId].hit(idx)
              self.grid[x][y] = HitShipPiece(shipId, idx)
              result = FireResult.hit
              if self.ships[shipId].isSunk():
                  result = FireResult.sunk
      return result

#+end_src


To test the firing functionality, we will use the following property: given a
number of shots fired, the number of pieces on the board that are an instance of
=HitShipPiece= must match the sum of all the cardinalities of the =hits= set of
all ships on the board. Since for testing this property we need a populated
board, we can also implement a =Board.populate= method, which will also come in
handy later on for placing the ships for our "AI".

The =Board.populate= method will take a list of lengths, and fit them randomly
on the board (since the game rules state the number and size of the ships, as
well as the size of the board, and we know that a placement is always feasible,
we won't check for feasibility of the placement in this method).

#+begin_src python :exports code :results silent :eval never :noweb-ref boardPopulate
  def populate(self, sizes):
      for s in sizes:
          done = False
          while not done:
              orientation = choice(list(Orientation))
              maxX = self.width - 1 if orientation == Orientation.vertical else self.width - s
              maxY = self.height - 1 if orientation == Orientation.horizontal else self.height - s
              x = randint(0, maxX)
              y = randint(0, maxY)
              if self.canAdd(x, y, s, orientation):
                  self.addShip(x, y, s, orientation)
                  done = True
#+end_src


Let us now test the =fire= method as discussed above:

#+begin_src python :exports code :results silent :eval never  :noweb-ref "fireTests"
  @given(st.data())
  def testShipFire(data):
      """We check that given a list of firing coordinates on the board, after firing, the
      number of `HitShipPiece` instances on the grid is the same as the sum of cardinalities
      for all the ships' hits on the board (populated as per the game rules)."""
      b = Board(10,10)
      b.populate([2, 3, 3, 4, 5])
      coords = st.tuples(st.integers(min_value=0, max_value=9),
                         st.integers(min_value=0, max_value=9))
      fireCoordinates = data.draw(st.lists(coords, min_size = 1, max_size = 50))
      for (x, y) in fireCoordinates:
          b.fire(x, y)
      hitPieces = sum([1 for i in range(0, b.width) for j in range(0, b.height)
                       if isinstance(b.grid[i][j], HitShipPiece)])
      cardinalities = sum([len(b.ships[k].hits) for k in b.ships.keys()])
      assert(hitPieces == cardinalities)

#+end_src



#+begin_src sh :exports both :results output 
pytest --cov=./
#+end_src

#+RESULTS:
#+begin_example
============================= test session starts ==============================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/mvr/Devel/Python/battleship
plugins: cov-2.8.1, hypothesis-5.6.0
collected 3 items

battleship/test_board.py ...                                             [100%]

----------- coverage: platform linux, python 3.6.9-final-0 -----------
Name                       Stmts   Miss  Cover
----------------------------------------------
battleship/board.py           86     13    85%
battleship/pieces.py          23      4    83%
battleship/ship.py             9      0   100%
battleship/test_board.py      53      0   100%
setup.py                       2      2     0%
----------------------------------------------
TOTAL                        173     19    89%


============================== 3 passed in 0.82s ===============================
#+end_example


#+begin_src python :exports code :results silent :eval never :noweb-ref boardPopulate
  def populate(self, sizes):
      for s in sizes:
          done = False
          while not done:
              orientation = choice(list(Orientation))
              maxX = self.width - 1 if orientation == Orientation.vertical else self.width - s
              maxY = self.height - 1 if orientation == Orientation.horizontal else self.height - s
              x = randint(0, maxX)
              y = randint(0, maxY)
              if self.canAdd(x, y, s, orientation):
                  self.addShip(x, y, s, orientation)
                  done = True
#+end_src

Finally, we add a method to test whether the board is "lost" (all ships are sunk)


#+begin_src python :exports code :results silent :eval never :noweb-ref boardLost
  def hasLost(self):
    return all([self.ships[k].isSunk() for k in self.ships.keys()])
#+end_src

*** AI

    For the "AI" part, we will adopt a simple strategy:
    - First, we note that since all the ships' lengths are at least two, we can
      start testing alternate cells, in a checkerboard pattern. This allows us
      to half the number of starting positions to test.
    - Secondly, while it'd be simpler to do this in order, it would be too easy
      to play against, as the player could simply cram their ships on the
      "opposite corner" of where the scan starts, in order to gain time
    - For the actual detection, we will check the 4 adjacent cells (or those
      that are valid, anyway), and upon detecting a hit, we can start moving in
      the corresponding orientation, towards both sides of the original cell,
      until the ship pointed at by the original hit cell is sunk, or we can
      detect that adjacent hits corresponded to a different, but adjacent ship
      (there are several edge cases to consider). Using the ship =id= to detect
      whether we're hitting the same ship could be considered "cheating", since
      the human player doesn't have access to the same information, so an
      alternative would be to do without, and just move across adjacent cells in
      a DSF manner, until a ship is sunk, or we run out of hits (meaning we
      reached the end of a ship, but haven't sunk it)

 
#+begin_src python :exports code :results silent :eval never :noweb yes :tangle "battleship/ai.py"
  from battleship.board import Board, Orientation, FireResult
  from random import choice

  def even(n):
          return 0 == n % 2

  def odd(n):
          return 1 == n % 2

  class AI:
      def checkerboardCoordinates(self):
          """Returns a list of alternating coordinates to target"""
          return [(i, j) for i in range(0, self.width)
                    for j in range(0, self.height)
                    if (even(i) and odd(j)) or (odd(i) and even(j))] 

      def adjacents(self, x, y):
          coords = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
          return [(i, j) for (i, j) in coords
                  if (i >= 0) and (x < self.width)
                  and (j >= 0) and (j < self.height)]

      def __init__(self, board):
          self.board = board
          self.width = board.width
          self.height = board.height
          self.explored = set()
          self.searchingGlobally = True
          self.remaining = self.checkerboardCoordinates()
          self.finished = False
          self.stack = []

      def addToLocalSearch(self, x, y):
          adjCoords = [a for a in self.adjacents(x, y)
                       if not(a in self.explored)]
          if len(adjCoords) > 0:
              for a in adjCoords:
                  self.stack.append(a)
                  self.searchingGlobally = False
                  if(a in self.remaining):
                          self.remaining.remove(a)

      def search(self):
          """Random firing over the remaining checkerboard coordinates"""
          if len(self.remaining) == 0:
              self.finished = True
              return
          elem = (x, y) = choice(self.remaining)
          self.remaining.remove(elem)
          outcome = self.board.fire(x, y)
          self.explored.add(elem)
          if outcome != FireResult.water:
              self.addToLocalSearch(x, y)

      def handleEmptyStack(self):
          """If the stack becomes empty during the local search, we need
          to go back to a global search, in the same turn"""
          self.searchingGlobally = True
          self.search()

      def localSearch(self):
          """Do a DFS around a cell that is known to be part of a ship"""
          if len(self.stack) == 0:
              self.handleEmptyStack()
              return
          done = False
          while not done:
              try:
                  elem = (x, y) = self.stack.pop()
                  if not elem in self.explored:
                      done = True
              except IndexError:
                  self.handleEmptyStack()
                  return
          outcome = self.board.fire(x, y)
          self.explored.add(elem)
          if outcome != FireResult.water:
              self.addToLocalSearch(x, y)


      def playTurn(self):
          """Plays the next turn. If we don't have a list of likely ship locations, we will
          randomly sample from the not-yet visited positions in the checkerboard pattern. If
          we have hit something, we will perform a local search in the surrounding positions in the grid,
          depth-first"""
          if self.searchingGlobally:
              self.search()
          else:
              self.localSearch()
#+end_src

The =AI= class has a simple API in the form of =playTurn=. We will exercise it
via generative testing:


#+begin_src python :exports code :results silent :eval never :noweb yes :tangle "battleship/test_ai.py"
  from battleship.board import Board
  from battleship.ai import AI
  from hypothesis import given, strategies as st

  @given(st.integers(min_value=5, max_value=50))
  def testCheckerboard(side):
      b = Board(side, side)
      ai = AI(b)
      checkerboard = ai.checkerboardCoordinates()
      assert(len(checkerboard) == ((side * side) // 2))

  @given(st.data())
  def testGameCompletion(data):
      numberOfGames = data.draw(st.integers(min_value=1, max_value=50))
      for i in range(0, numberOfGames):
          b = Board(10, 10)
          b.populate([2, 3, 3, 4, 5])
          ai = AI(b)
          while not ai.finished:
              ai.playTurn()
          assert(all([b.ships[k].isSunk() for k in b.ships.keys()]))

#+end_src


Let us now run the tests to check that everything is working as expected, and
what our code coverage looks like:

#+begin_src sh :exports both :results output 
pytest --cov=battleship
#+end_src

#+RESULTS:
#+begin_example
============================= test session starts ==============================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/mvr/Devel/Python/battleship
plugins: cov-2.8.1, hypothesis-5.6.0
collected 5 items

battleship/test_ai.py ..                                                 [ 40%]
battleship/test_board.py ...                                             [100%]

----------- coverage: platform linux, python 3.6.9-final-0 -----------
Name                       Stmts   Miss  Cover
----------------------------------------------
battleship/__init__.py         4      0   100%
battleship/ai.py              63      0   100%
battleship/board.py          100     24    76%
battleship/game.py             1      1     0%
battleship/pieces.py          25      6    76%
battleship/ship.py             9      0   100%
battleship/test_ai.py         17      0   100%
battleship/test_board.py      53      0   100%
----------------------------------------------
TOTAL                        272     31    89%


============================== 5 passed in 2.33s ===============================
#+end_example

*** The Game
    With all the board mechanics and AI in place, we can now code a CLI driver
    for the game.
